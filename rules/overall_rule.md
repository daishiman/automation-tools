# 変更容易性と拡張性を重視したMVPアーキテクチャ設計ガイド

本ドキュメントでは、費用をかけずに開発できるMVPシステムのアーキテクチャ設計について詳細に解説します。変更容易性と拡張性を最大化し、将来の要件変更やスケーリングに柔軟に対応できる構成を提示します。特にMastraを活用したAIシステム構築のベストプラクティスを含め、すべてのエンジニアが共通認識を持てるよう設計しています。

## 目次

1. [コアアーキテクチャ](#1-コアアーキテクチャ)
2. [インフラストラクチャ](#2-インフラストラクチャ)
3. [データベース設計とORM](#3-データベース設計とドリズルorm)
4. [バックエンド構成](#4-バックエンド設計)
5. [フロントエンド設計](#5-フロントエンド設計)
6. [ディレクトリ構造](#6-ディレクトリ構造)
7. [認証・認可システム](#7-認証認可システム)
8. [エラーハンドリング](#8-エラーハンドリングとロギング)
9. [状態管理とデータフロー](#9-状態管理とデータフロー)
10. [国際化(i18n)戦略](#10-国際化i18n戦略)
11. [モニタリングと分析](#11-モニタリングと分析)
12. [スケーリング戦略](#12-スケーリング戦略)
13. [開発ワークフロー](#13-開発ワークフロー)
14. [テスト戦略](#14-テスト戦略)
15. [変更容易性確保のための設計原則](#15-変更容易性を確保するための設計原則)
16. [Mastraを活用したAIシステム構築](#16-mastraを活用したaiシステム構築)
17. [まとめ](#17-まとめ)
18. [付録](#付録-開発準備チェックリスト)

## 1. コアアーキテクチャ

### 基本技術スタック（確定）

| 項目                       | 選定技術                             | 選定理由                                                               |
| -------------------------- | ------------------------------------ | ---------------------------------------------------------------------- |
| **プログラミング言語**     | TypeScript 5.3.2+                    | 静的型付けによる安全性、リファクタリング容易性、開発時エラー検出能力   |
| **フレームワーク**         | Next.js 14.0.3+ (App Router)         | フロント/バックエンド統合、エッジ対応、サーバーコンポーネント          |
| **アーキテクチャパターン** | クリーンアーキテクチャ + DDD         | 明確な関心の分離、ドメインロジックの独立性、変更の局所化               |
| **レイヤー構造**           | ドメイン・インフラ・インターフェース | 責任の明確な分離と一方向の依存関係                                     |
| **AIフレームワーク**       | Mastra 1.0+                          | エージェントとワークフローベースの柔軟なAI活用、アシスタントアプリ構築 |
| **Node.js**                | v18.18.0以上（v20.10.0推奨）         | 長期サポート、安定性、最新機能サポート                                 |

### アーキテクチャの核となる設計原則

1. **境界づけられたコンテキスト**: ビジネスドメインごとに明確な境界を設定
   - 独立したドメインモデル
   - 明確に定義された責任範囲
   - コンテキスト間の関係の明示的マッピング
2. **依存性逆転の原則**: 上位レイヤー（ドメイン）は下位レイヤー（インフラ）に依存しない
   - インターフェースによる抽象化
   - 依存方向の一方向性の維持
   - 具体実装の交換容易性
3. **単一責任の原則**: 各コンポーネントは明確に定義された1つの責任のみを持つ
   - 責任境界の明確な定義
   - 変更理由の局所化
   - テスト容易性の向上
4. **ドメインロジックの独立**: ビジネスルールはインフラストラクチャから完全に分離
   - 技術的制約からの解放
   - ビジネスルールの純粋な表現
   - 長期的な価値の保存
5. **テスト容易性**: すべてのコンポーネントは単体テスト可能な設計
   - 依存関係のモック化容易性
   - ビジネスロジックの分離テスト
   - 高いテストカバレッジの実現

## 2. インフラストラクチャ

### クラウドプラットフォーム（確定: Cloudflare）

| 項目                 | 選定技術             | 無料枠制限                               | 選定理由                                   |
| -------------------- | -------------------- | ---------------------------------------- | ------------------------------------------ |
| **ホスティング**     | Cloudflare Pages     | 無制限サイト、月500ビルド、月100GB帯域幅 | グローバルCDN、CI/CD統合、無料枠の充実     |
| **サーバーレス処理** | Cloudflare Workers   | 月10万リクエスト                         | エッジでの低レイテンシー処理、D1との統合   |
| **CI/CD**            | GitHub Actions       | 月2,000分の無料実行時間                  | 広く採用されている、柔軟なワークフロー設定 |
| **モニタリング**     | Cloudflare Analytics | 基本的な分析は無料                       | Cloudflareエコシステムとの統合、簡単設定   |

### データストレージ（確定）

| 項目                   | 選定技術      | 無料枠制限                 | 選定理由                                      |
| ---------------------- | ------------- | -------------------------- | --------------------------------------------- |
| **メインデータベース** | Cloudflare D1 | 5GB/月500万クエリ          | SQLite互換、Workersとの最適化された接続       |
| **キャッシュ**         | Cloudflare KV | 1GB/日10万読取、日1000書込 | 高速読み取り、グローバル分散、Workers統合     |
| **ファイルストレージ** | Cloudflare R2 | 10GB/月無料                | S3互換API、エッジからの低レイテンシーアクセス |
| **ORM**                | Drizzle ORM   | -                          | D1に最適化、軽量、SQLライクな構文、型安全性   |
| **ベクトルストア**     | Vectorize     | 無料枠あり                 | Cloudflare製、RAG実装のための埋め込み保存     |

### スケーリング戦略（確定）

**段階的アプローチ**:

1. **初期フェーズ (0-500万クエリ/月)**:

   - D1の最適化（インデックス、効率的なクエリ）
   - KVによるホットデータのキャッシュ
   - Mastraの処理の単純化と最適化

2. **成長フェーズ (500万以上/月)**:
   - PlanetScaleへの段階的移行（MySQLベース）
   - リポジトリ実装の交換のみで移行可能な設計

## 3. データベース設計とドリズルORM

### Drizzle ORMの特徴（確定）

1. **D1との最適な互換性**: Cloudflare D1に特化した設計
2. **軽量設計**: 最小限のバンドルサイズと実行時オーバーヘッド
3. **型安全**: TypeScriptとの完全な統合
4. **SQLライク構文**: SQLに近い直感的なクエリビルダー
5. **マイグレーション管理**: スキーマ変更の追跡と適用

### データモデリング原則

1. **スキーマファースト設計**: スキーマ定義を中心としたデータモデリング
   - 明確な型定義による安全性確保
   - スキーマの一元管理
   - マイグレーション自動生成の基盤
2. **適切な正規化**: パフォーマンスと整合性のバランスを考慮
   - 3NF（第三正規形）を基本とした設計
   - 頻繁に結合するエンティティの慎重な非正規化
   - インデックス戦略との連携
3. **インデックス最適化**: クエリパターンに基づく効率的なインデックス設計
   - 実際の使用パターンに基づく選定
   - 複合インデックスの適切な活用
   - メンテナンスコストを考慮した数の管理
4. **明示的なリレーション**: 関連性を明確に定義
   - 外部キー制約の活用
   - 参照整合性の確保
   - リレーション型の適切な選択（1:1, 1:N, N:M）
5. **型安全**: 厳格な型付けによる堅牢性の確保
   - ドメイン固有型の活用
   - Zodによるバリデーションスキーマとの連携
   - 一貫したnull/undefined処理

### リポジトリパターンの実装

```typescript
// domain/repositories/user-repository.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  save(user: User): Promise<User>;
  // その他のメソッド
}

// infrastructure/database/repositories/drizzle-user-repository.ts
export class DrizzleUserRepository implements UserRepository {
  constructor(private db: DrizzleClient) {}

  async findById(id: string): Promise<User | null> {
    const result = await this.db.select().from(users).where(eq(users.id, id)).get();
    return result ? this.mapToEntity(result) : null;
  }

  // その他のメソッド実装
}
```

## 4. バックエンド設計

### 選定アーキテクチャ（確定）

| 項目                   | 選定パターン       | 選定理由                             |
| ---------------------- | ------------------ | ------------------------------------ |
| **APIアーキテクチャ**  | REST               | シンプルさ、標準的な手法、広い理解   |
| **データアクセス**     | リポジトリパターン | データソース抽象化、実装の交換容易性 |
| **クエリ構築**         | クエリビルダー     | 複雑なクエリの構築と再利用性         |
| **ビジネスロジック**   | ドメインサービス   | ドメインロジックの集約とテスト容易性 |
| **エラーハンドリング** | 統合エラー処理     | 一貫したエラーレスポンス形式         |

### APIルート設計

```typescript
// app/api/users/[id]/route.ts
import { NextResponse } from 'next/server';
import { container } from '@/lib/di/container';
import { getUserUseCase } from '@/domain/users/usecases';
import { NotFoundError, ValidationError, AuthError } from '@/lib/errors';
import { handleApiError } from '@/lib/api/error-handler';

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    // 依存性注入コンテナからユースケースを解決
    const useCase = container.resolve(getUserUseCase);

    // ユースケースを実行（ドメインロジックを含む）
    const user = await useCase.execute({ id: params.id });

    if (!user) {
      throw new NotFoundError('USER_NOT_FOUND', 'User not found');
    }

    // 成功レスポンスの返却
    return NextResponse.json({ user });
  } catch (error) {
    // 集中型エラーハンドラによる一貫した処理
    return handleApiError(error);
  }
}

// lib/api/error-handler.ts
export function handleApiError(error: unknown): NextResponse {
  // エラータイプに応じた適切なレスポンス
  if (error instanceof ValidationError) {
    return NextResponse.json(
      {
        error: {
          code: error.code,
          message: error.message,
          details: error.details,
        },
      },
      { status: 400 }
    );
  }

  if (error instanceof NotFoundError) {
    return NextResponse.json(
      { error: { code: error.code, message: error.message } },
      { status: 404 }
    );
  }

  if (error instanceof AuthError) {
    return NextResponse.json(
      { error: { code: error.code, message: error.message } },
      { status: 401 }
    );
  }

  // 未知のエラーは内部サーバーエラーとして処理
  console.error('Unhandled error:', error);
  return NextResponse.json(
    {
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: '内部サーバーエラーが発生しました',
      },
    },
    { status: 500 }
  );
}
```

## 5. フロントエンド設計

### 選定技術（確定）

| 項目                 | 選定技術              | 選定理由                                     |
| -------------------- | --------------------- | -------------------------------------------- |
| **UIフレームワーク** | React (Next.js)       | サーバーコンポーネント、高い生産性           |
| **スタイリング**     | TailwindCSS           | ユーティリティファースト、柔軟なカスタマイズ |
| **UIコンポーネント** | shadcn/ui             | コピー可能コンポーネント、TailwindCSS統合    |
| **状態管理**         | Zustand               | シンプルなAPI、最小限のボイラープレート      |
| **データフェッチ**   | TanStack Query        | サーバー状態管理、エラーハンドリング         |
| **フォーム管理**     | React Hook Form + Zod | パフォーマンス、型安全なバリデーション       |
| **AI連携**           | Mastra                | エージェント・ワークフローによるAI活用       |

### コンポーネント設計原則

1. **アトミックデザイン**: 再利用可能な小さなコンポーネントからの構築

   - 原子（Atoms）: ボタン、入力フィールドなどの基本要素
   - 分子（Molecules）: 複数の原子を組み合わせた機能単位
   - 有機体（Organisms）: 分子の組み合わせによる複雑な機能ブロック
   - テンプレート: ページレイアウトの骨格
   - ページ: 実際のコンテンツを持つビュー

2. **コンポジション優先**: 継承よりもコンポジション

   - 単一責任の小さなコンポーネント
   - カスタマイズはプロップスを通じて実現
   - 高階コンポーネントの適切な活用
   - コンテキストの限定的な使用

3. **関心の分離**: プレゼンテーションとロジックの分離

   - 表示ロジックと状態管理の明確な分離
   - カスタムフックによるロジックの抽出
   - サーバーコンポーネントとクライアントコンポーネントの適切な分割
   - データフェッチングの責任範囲の明確化

4. **明示的なプロップス**: 明確なインターフェース定義

   - TypeScriptによる型定義
   - デフォルト値の適切な設定
   - 必須プロップスの明示
   - PropsWithChildrenの活用

5. **レスポンシブデザイン**: モバイルファーストでのUI設計
   - TailwindCSSのブレークポイントの一貫した活用
   - コンテナクエリの適切な使用
   - アクセシビリティ考慮によるユーザビリティ確保
   - ダークモード対応

## 6. ディレクトリ構造

### Next.js + Mastraによる推奨ディレクトリ構成（確定）

```
/
├── src/
│   ├── app/                       # UI層（プレゼンテーション層）
│   │   ├── page.tsx               # トップページ
│   │   ├── layout.tsx             # レイアウト設定
│   │   ├── globals.css            # グローバルCSS
│   │   ├── (routes)/              # ルートグループ
│   │   │   ├── (auth)/            # 認証関連ルート
│   │   │   │   └── [feature]/     # 認証関連機能ページ
│   │   │   ├── (dashboard)/       # ダッシュボード関連ルート
│   │   │   │   └── [feature]/     # ダッシュボード関連機能ページ
│   │   │   └── (marketing)/       # マーケティングページ
│   │   │       └── [feature]/     # マーケティング関連機能ページ
│   │   ├── api/                   # APIルート（インターフェース層）
│   │   │   └── [feature]/         # 機能別API
│   │   └── webhooks/              # Webhookエンドポイント
│   │       └── [feature]/         # 機能別Webhook
│   │
│   ├── domain/                    # ドメイン層（ビジネスロジック）
│   │   ├── [feature]/             # 機能ごとのモジュール
│   │   │   ├── entities.ts        # エンティティ定義
│   │   │   ├── repositories.ts    # リポジトリインターフェース
│   │   │   ├── services.ts        # ドメインサービス
│   │   │   ├── errors.ts          # ドメイン固有エラー
│   │   │   └── validators.ts      # バリデーションスキーマ
│   │   └── shared/                # 共有ドメインロジック
│   │       └── [shared-feature]/  # 共有機能モジュール
│   │
│   ├── infrastructure/            # インフラストラクチャ層（外部システム連携）
│   │   ├── database/              # データベース関連
│   │   │   ├── drizzle/           # Drizzle ORM設定
│   │   │   │   └── [feature]/     # 機能別スキーマ定義
│   │   │   ├── repositories/      # リポジトリ実装（ドメインインターフェースの実装）
│   │   │   │   └── [feature]/     # 機能別リポジトリ実装
│   │   │   └── queryBuilders/     # クエリビルダー
│   │   │       └── [feature]/     # 機能別クエリビルダー
│   │   ├── auth/                  # 認証サービス実装
│   │   │   └── [feature]/         # 認証関連機能実装
│   │   └── storage/               # ストレージサービス実装
│   │       └── [feature]/         # ストレージ関連機能実装
│   │
│   ├── mastra/                    # Mastra AIフレームワーク（ドメイン特化層）
│   │   ├── README.md              # フレームワークの説明
│   │   ├── index.ts               # エントリーポイント
│   │   ├── core/                  # フレームワークコア（抽象化）
│   │   │   ├── index.ts           # コアエントリーポイント
│   │   │   ├── models/            # モデル抽象化
│   │   │   │   ├── index.ts       # モデルエクスポート
│   │   │   │   └── [model-type]/  # 特定モデルタイプの実装
│   │   │   ├── workflows/         # ワークフロー抽象化
│   │   │   │   ├── index.ts       # ワークフローエクスポート
│   │   │   │   └── [workflow-type]/ # 特定ワークフロータイプの実装
│   │   │   ├── tools/             # ツール抽象化
│   │   │   │   ├── index.ts       # ツールエクスポート
│   │   │   │   └── [tool-type]/   # 特定ツールタイプの実装
│   │   │   └── managers/          # マネージャー抽象化
│   │   │       ├── index.ts       # マネージャーエクスポート
│   │   │       └── [manager-type]/ # 特定マネージャータイプの実装
│   │   ├── types/                 # 型定義（契約）
│   │   │   ├── index.ts           # 型定義エントリーポイント
│   │   │   ├── mastra-core.d.ts   # コア型定義
│   │   │   ├── models/            # モデル型定義
│   │   │   │   ├── index.ts       # モデル型エクスポート
│   │   │   │   └── [model-type].ts # 特定モデル型定義
│   │   │   ├── workflows/         # ワークフロー型定義
│   │   │   │   ├── index.ts       # ワークフロー型エクスポート
│   │   │   │   └── [workflow-type].ts # 特定ワークフロー型定義
│   │   │   ├── tools/             # ツール型定義
│   │   │   │   ├── index.ts       # ツール型エクスポート
│   │   │   │   └── [tool-type].ts # 特定ツール型定義
│   │   │   └── managers/          # マネージャー型定義
│   │   │       ├── index.ts       # マネージャー型エクスポート
│   │   │       └── [manager-type].ts # 特定マネージャー型定義
│   │   ├── agents/                # AIエージェント定義
│   │   │   └── [feature]/         # 機能別エージェント
│   │   │       ├── index.ts       # エージェントエクスポート
│   │   │       └── [agent-name].ts # 特定エージェント実装
│   │   ├── workflows/             # ワークフロー定義
│   │   │   ├── [feature]/         # 機能別ワークフローグループ
│   │   │   │   ├── index.ts       # ワークフローエクスポート
│   │   │   │   └── [workflow-name].ts # 特定ワークフロー実装
│   │   │   └── [workflow].ts      # 個別ワークフロー
│   │   ├── tools/                 # カスタムツール
│   │   │   ├── [feature]/         # 機能別ツールグループ
│   │   │   │   ├── index.ts       # ツールエクスポート
│   │   │   │   └── [tool-name].ts # 特定ツール実装
│   │   │   └── [tool].ts          # 個別ツール
│   │   ├── rag/                   # RAG実装
│   │   │   └── [feature]/         # 機能別RAG実装
│   │   │       ├── index.ts       # RAGエクスポート
│   │   │       ├── retrieval.ts   # 検索実装
│   │   │       ├── generation.ts  # 生成実装
│   │   │       └── indexing.ts    # インデックス実装
│   │   ├── evals/                 # 評価モジュール
│   │   │   └── [feature]/         # 機能別評価
│   │   │       ├── index.ts       # 評価エクスポート
│   │   │       └── metrics.ts     # 評価指標実装
│   │   ├── shared/                # 共有ユーティリティ
│   │   │   ├── README.md          # 共有機能の説明
│   │   │   ├── core/              # 共有コア機能
│   │   │   │   └── [feature]/     # 共有コア機能グループ
│   │   │   ├── types/             # 共有型定義
│   │   │   │   ├── index.ts       # 型定義エントリーポイント
│   │   │   │   ├── mastra-core.d.ts # コア型定義
│   │   │   │   ├── workflows/     # ワークフロー型定義
│   │   │   │   │   ├── index.ts   # ワークフロー型エクスポート
│   │   │   │   │   └── [workflow-type].ts # 特定ワークフロー型定義
│   │   │   │   ├── tools/         # ツール型定義
│   │   │   │   │   ├── index.ts   # ツール型エクスポート
│   │   │   │   │   └── [tool-type].ts # 特定ツール型定義
│   │   │   │   ├── models/        # モデル型定義
│   │   │   │   │   ├── index.ts   # モデル型エクスポート
│   │   │   │   │   └── [model-type].ts # 特定モデル型定義
│   │   │   │   ├── managers/      # マネージャー型定義
│   │   │   │   │   ├── index.ts   # マネージャー型エクスポート
│   │   │   │   │   └── [manager-type].ts # 特定マネージャー型定義
│   │   │   │   └── prompts/       # プロンプト型定義
│   │   │   │       ├── index.ts   # プロンプト型エクスポート
│   │   │   │       └── [prompt-type].ts # 特定プロンプト型定義
│   │   │   └── constants/         # 共有定数
│   │   │       ├── index.ts       # 定数エントリーポイント
│   │   │       ├── message-formats.ts # メッセージフォーマット
│   │   │       └── prompts/       # プロンプトテンプレート
│   │   │           ├── index.ts   # プロンプトエントリーポイント
│   │   │           ├── agents/    # エージェントプロンプト
│   │   │           │   └── [agent-type]/ # エージェントタイプ別プロンプト
│   │   │           ├── rag/       # RAGプロンプト
│   │   │           │   └── [rag-type]/ # RAGタイプ別プロンプト
│   │   │           ├── code/      # コード関連プロンプト
│   │   │           │   └── [language]/ # 言語別プロンプト
│   │   │           └── [feature].ts # 機能別プロンプト
│   │   ├── integrations/          # 外部API型安全クライアント
│   │   │   └── [service]/         # サービス別クライアント
│   │   │       ├── client.ts      # API クライアント
│   │   │       ├── types.ts       # サービス型定義
│   │   │       └── utils.ts       # サービスユーティリティ
│   │   ├── syncs/                 # バッチ/同期ワークフロー
│   │   │   └── [feature]/         # 機能別同期処理
│   │   │       ├── index.ts       # 同期処理エクスポート
│   │   │       └── scheduler.ts   # スケジューラー実装
│   │   ├── observability/         # ロギング・トレーシング
│   │   │   └── [feature]/         # 機能別監視実装
│   │   ├── memory/                # メモリ管理
│   │   │   └── [feature]/         # 機能別メモリ実装
│   │   └── constants/             # 定数定義
│   │       ├── [feature]/         # 機能別定数
│   │       └── message-formats.ts # メッセージフォーマット
│   │
│   ├── components/                # UI共通コンポーネント（プレゼンテーション層）
│   │   ├── ui/                    # 基本UIコンポーネント
│   │   │   └── [component-type]/  # コンポーネントタイプ別
│   │   ├── [feature]/             # 機能別コンポーネント
│   │   │   ├── index.ts           # コンポーネントエクスポート
│   │   │   ├── types.ts           # コンポーネント型定義
│   │   │   └── [component-name].tsx # 特定コンポーネント実装
│   │   ├── layout/                # レイアウトコンポーネント
│   │   │   └── [layout-type]/     # レイアウトタイプ別
│   │   └── shared/                # 共通コンポーネント
│   │       └── [shared-component]/ # 共有コンポーネントグループ
│   │
│   ├── hooks/                     # カスタムReactフック（ビジネスロジックとUIの橋渡し）
│   │   └── [feature]/             # 機能別フック
│   │       ├── index.ts           # フックエクスポート
│   │       └── use-[hook-name].ts # 特定フック実装
│   │
│   ├── lib/                       # 共通ユーティリティ層
│   │   ├── utils/                 # 汎用ユーティリティ
│   │   │   └── [utility-type]/    # ユーティリティタイプ別
│   │   ├── api/                   # API通信ヘルパー
│   │   │   └── [feature]/         # 機能別API通信
│   │   │       ├── index.ts       # APIヘルパーエクスポート
│   │   │       └── client.ts      # APIクライアント実装
│   │   ├── auth/                  # 認証ヘルパー
│   │   │   └── [auth-feature]/    # 認証機能別ヘルパー
│   │   ├── di/                    # 依存性注入コンテナ（依存性逆転の原則を実現）
│   │   │   └── [feature]/         # 機能別DIコンテナ
│   │   ├── errors/                # エラーハンドリング
│   │   │   └── [feature]/         # 機能別エラーハンドリング
│   │   └── config/                # 設定管理
│   │       └── [feature]/         # 機能別設定
│   │
│   ├── scripts/                   # スクリプト（ユーティリティツール）
│   │   ├── [feature]/             # 機能別スクリプト
│   │   ├── create-commit-msg.ts   # コミットメッセージ生成
│   │   └── create-pr.ts           # PR作成
│   │
│   ├── stores/                    # 状態管理（アプリケーション状態）
│   │   └── [feature]/             # 機能別ストア
│   │       ├── index.ts           # ストアエクスポート
│   │       ├── types.ts           # ストア型定義
│   │       └── actions.ts         # ストアアクション
│   │
│   └── types/                     # グローバル型定義
│       ├── README.md              # 型定義の説明
│       ├── [feature]/             # 機能別グローバル型定義
│       └── mastra.ts              # Mastra関連のグローバル型定義
│
├── tests/                         # テスト
│   ├── unit/                      # 単体テスト（各モジュールの独立テスト）
│   │   ├── [feature]/             # 機能別単体テスト
│   │   │   ├── [module].test.ts   # 特定モジュールのテスト
│   │   │   └── __snapshots__/     # スナップショットテスト結果
│   │   ├── domain/                # ドメイン層テスト
│   │   │   └── [feature]/         # 機能別ドメインテスト
│   │   ├── mastra/                # Mastra関連テスト
│   │   │   └── [feature]/         # 機能別Mastraテスト
│   │   └── helpers/               # テストヘルパー
│   │       ├── setup.ts           # テスト設定
│   │       ├── mocks/             # モックオブジェクト
│   │       │   └── [feature]/     # 機能別モック
│   │       └── factories/         # テストデータファクトリー
│   │           └── [feature]/     # 機能別ファクトリー
│   │
│   ├── integration/               # 統合テスト（モジュール間連携テスト）
│   │   ├── [feature]/             # 機能別統合テスト
│   │   │   ├── [workflow].test.ts # 特定ワークフローテスト
│   │   │   └── [integration-point].test.ts # 特定統合ポイントテスト
│   │   ├── api/                   # API統合テスト
│   │   │   └── [feature]/         # 機能別APIテスト
│   │   ├── database/              # データベース統合テスト
│   │   │   └── [feature]/         # 機能別DBテスト
│   │   ├── mastra/                # Mastra統合テスト
│   │   │   └── [feature]/         # 機能別Mastra統合テスト
│   │   └── helpers/               # 統合テストヘルパー
│   │       ├── setup.ts           # 統合テスト設定
│   │       ├── mocks/             # 統合テスト用モック
│   │       │   └── [service]/     # サービス別モック
│   │       └── fixtures/          # テストフィクスチャ
│   │           └── [feature]/     # 機能別フィクスチャ
│   │
│   ├── e2e/                       # E2Eテスト（ユーザーフロー全体テスト）
│   │   ├── [feature]/             # 機能別E2Eテスト
│   │   │   └── [user-flow].test.ts # 特定ユーザーフローテスト
│   │   ├── pages/                 # ページオブジェクトモデル
│   │   │   └── [page-name].ts     # 特定ページのアクセサ
│   │   ├── workflows/             # 複数ページにまたがるワークフロー
│   │   │   └── [workflow-name].ts # 特定ワークフロー
│   │   └── helpers/               # E2Eテストヘルパー
│   │       ├── setup.ts           # E2Eテスト設定
│   │       ├── commands/          # カスタムコマンド
│   │       │   └── [command-name].ts # 特定コマンド
│   │       └── fixtures/          # E2Eテスト用フィクスチャ
│   │           └── [feature]/     # 機能別フィクスチャ
│   │
│   ├── performance/               # パフォーマンステスト
│   │   ├── [feature]/             # 機能別パフォーマンステスト
│   │   │   └── [scenario].test.ts # 特定シナリオテスト
│   │   └── metrics/               # パフォーマンス計測
│   │       └── [metric-type]/     # 計測タイプ別
│   │
│   ├── __mocks__/                 # グローバルモック
│   │   └── [module]/              # モジュール別モック
│   │
│   ├── fixtures/                  # 共有テストフィクスチャ
│   │   └── [feature]/             # 機能別フィクスチャ
│   │       ├── data.json          # テストデータ
│   │       └── responses.json     # モックレスポンス
│   │
│   └── config/                    # テスト設定
│       ├── vitest.config.ts       # Vitestメイン設定
│       ├── vitest.unit.ts         # 単体テスト設定
│       ├── vitest.integration.ts  # 統合テスト設定
│       └── vitest.e2e.ts          # E2Eテスト設定
│
├── public/                        # 静的ファイル
├── scripts/                       # シェルスクリプト
├── rules/                         # プロジェクトルール
├── .env.example                   # 環境変数テンプレート
├── next.config.js                 # Next.js設定
├── tailwind.config.js             # Tailwind設定
└── drizzle.config.ts              # Drizzle設定
```

### ディレクトリ構造の原則

1. **機能による分割**: 関連する機能をグループ化
2. **レイヤー分離**: ドメイン、インフラ、インターフェースの明確な分離
3. **自己文書化**: ディレクトリ構造自体がアーキテクチャを表現
4. **関心の分離**: 責任範囲ごとの明確な分離
5. **テスト容易性**: モジュール単位でのテストが容易な構造

### レイヤー間の依存関係

```
UI層 (app/, components/) → Hooks層 (hooks/) → ドメイン層 (domain/) ← インフラ層 (infrastructure/)
                         ↘                  ↗
                           共通ユーティリティ (lib/)
```

- **ドメイン層**は他のどの層にも依存しない（内向きの依存）
- **インフラ層**はドメイン層のインターフェースに依存（依存性逆転）
- **UI層**はドメイン層とフックを利用して状態管理とビジネスロジックにアクセス

## 7. 認証・認可システム

### JWT + Cloudflare Workers KV（確定）

| 機能             | 実装アプローチ                    | メリット                             |
| ---------------- | --------------------------------- | ------------------------------------ |
| **認証方式**     | JWT + KV                          | Cloudflareエコシステムとの統合       |
| **トークン管理** | セッション + リフレッシュトークン | セキュリティとUX向上                 |
| **権限管理**     | ロールベース                      | シンプルで拡張性のある権限管理       |
| **ミドルウェア** | Edge Middleware                   | すべてのルートで一貫した認証チェック |

### 実装ガイドライン

1. **トークンの安全性**: 適切な有効期限と更新メカニズム
   - アクセストークンの短い有効期限（15〜30分）
   - リフレッシュトークンによる透過的なセッション更新
   - セキュアな乱数生成によるトークンの予測不能性確保
   - セッション無効化機能の実装
2. **セキュアなCookie**: HttpOnly, Secure, SameSite属性
   - HttpOnly: JavaScriptからのアクセスを防止し、XSS攻撃からの保護を強化
   - Secure: HTTPS接続でのみCookieを送信し、中間者攻撃を防止
   - SameSite=Strict/Lax: クロスサイトリクエストでのCookie送信を制限しCSRF攻撃を防止
3. **CSRF対策**: CSRFトークンとOriginの検証
   - 状態変更操作に対するCSRFトークンの必須化
   - Origin/Refererヘッダーの検証による不正リクエストの検出
   - Double Submit Cookie方式の実装
4. **認可ロジック**: ミドルウェアによる一貫した権限チェック
   - ルートごとの細粒度な権限制御
   - ロールベースとリソースベースの組み合わせによる柔軟な認可
   - バックエンドとフロントエンドでの一貫した認可チェック
5. **エラー処理**: 明確な認証エラーメッセージ
   - ユーザーフレンドリーなエラーメッセージ
   - セキュリティリスクを最小化した情報開示
   - ログイン試行の制限と一時的なアカウントロック機能

## 8. エラーハンドリングとロギング

### エラー管理戦略（確定）

1. **階層化されたエラー**:

   - 基本エラークラス（`AppError`）
     - 共通属性: コード、メッセージ、詳細、スタックトレース
     - 一貫したエラー構造の基盤
   - ドメイン固有のエラーサブクラス
     - `ValidationError`: 入力検証エラー
     - `AuthError`: 認証・認可関連エラー
     - `NotFoundError`: リソース不在エラー
     - `ServiceError`: 外部サービス連携エラー
   - HTTPエラー変換レイヤー
     - ドメインエラーからHTTPステータスコードへの適切なマッピング
     - APIレスポンス形式の標準化

2. **統一されたエラーレスポンス形式**:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "ユーザーフレンドリーなメッセージ",
    "details": { "追加情報": "詳細" }
  }
}
```

3. **構造化ログ記録**:

   - JSONフォーマット
     - タイムスタンプ、ログレベル、サービス名などの標準フィールド
     - 構造化されたエラー情報の保存
   - リクエストID/トレースID
     - 分散システム間でのリクエスト追跡
     - エラー原因の特定と関連付け
   - コンテキスト情報の記録
     - ユーザーID、セッション情報（個人情報は排除）
     - 操作コンテキスト（機能、アクション）
   - ログレベルの適切な使用
     - ERROR: システム機能の障害
     - WARN: 潜在的問題の警告
     - INFO: 重要なイベント
     - DEBUG: 開発・トラブルシューティング情報

4. **Mastra特有のエラーハンドリング**:
   - エージェント実行エラーの捕捉
     - モデルエラー（トークン上限、生成失敗）の適切な処理
     - フォールバックメカニズムとリトライ戦略
   - ワークフローエラーの適切な処理
     - ステップ実行エラーの分離と記録
     - 部分的成功の処理とリカバリーオプション
   - ツール実行エラーのハンドリング
     - 外部サービス連携失敗の明確な報告
     - ユーザーへの適切なフィードバック
   - エラー分析とパフォーマンス改善
     - 共通エラーパターンの特定と対策
     - 継続的なエラーレート監視

## 9. 状態管理とデータフロー

### Zustand + TanStack Query（確定）

データフローの明確な分離:

1. **クライアント状態 (Zustand)**:

   - UIの状態（モーダル、展開状態など）
     - 一時的なUI状態の管理
     - コンポーネント間での状態共有
   - フォーム状態
     - 複雑なフォームの状態管理
     - フォーム間データの連携
   - 認証状態
     - ユーザー情報とトークン管理
     - 認証状態に基づくUI制御
   - テーマ設定
     - ユーザー設定の永続化
     - テーマ切り替えロジック

2. **サーバー状態 (TanStack Query)**:

   - API結果のキャッシュ
     - クエリキーによる効率的なキャッシュ管理
     - 適切なキャッシュ無効化戦略
   - 自動再取得
     - ウィンドウフォーカス時の更新
     - ポーリングによる定期的更新
   - 楽観的更新
     - レスポンス待ちなしのUI更新
     - 失敗時のロールバック処理
   - エラー処理とリトライ
     - 自動リトライポリシー
     - エラー状態のキャプチャと表示

3. **AIエージェント状態 (Mastra)**:
   - 会話履歴
     - 効率的なメモリ管理
     - コンテキスト長の最適化
   - エージェント状態
     - 進行中処理の状態追跡
     - 中断と再開のサポート
   - ワークフロー進行状況
     - ステップ完了状態の追跡
     - エラー発生ステップの特定
   - エージェント間状態共有
     - 共有コンテキストの管理
     - エージェント間の情報伝達

### 実装パターン

```typescript
// stores/auth-store.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AuthState {
  user: User | null;
  token: string | null;
  isLoading: boolean;
  login: (credentials: Credentials) => Promise<void>;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      token: null,
      isLoading: false,
      login: async (credentials) => {
        set({ isLoading: true });
        try {
          // ログイン処理
        } catch (error) {
          // エラー処理
        } finally {
          set({ isLoading: false });
        }
      },
      logout: () => {
        set({ user: null, token: null });
      },
    }),
    { name: 'auth-storage' }
  )
);

// hooks/use-users.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { UserService } from '@/domain/users/services';

export function useUsers() {
  const queryClient = useQueryClient();
  const service = new UserService();

  const users = useQuery({
    queryKey: ['users'],
    queryFn: () => service.getAll(),
  });

  const createUser = useMutation({
    mutationFn: (user: NewUser) => service.create(user),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });

  return { users, createUser };
}
```

## 10. 国際化(i18n)戦略

### next-intl採用（確定）

1. **構造化メッセージファイル**:

   - 言語ごとの分離
     - `messages/ja.json`, `messages/en.json`などの言語ファイル
     - 一貫したキー構造で全言語をカバー
   - 機能/コンポーネント別の階層構造
     - ページごとのネームスペース分離
     - コンポーネント単位での翻訳管理
   - 翻訳キーの命名規則
     - `section.subsection.element.description`形式の階層化
     - 一貫した命名パターンの維持

2. **機能**:

   - 複数言語サポート
     - 初期フェーズでは日英対応
     - スケーリング時に他言語拡張容易な設計
   - 日付/時刻/数値のローカライズ
     - intl-relativetimeformatによる相対時間表示
     - 数値、通貨のロケールに応じた表示
   - メッセージフォーマット（変数、複数形）
     - ICU Message Formatに基づくプレースホルダー処理
     - 複数形ルールの適切な処理
   - サーバー/クライアント両方での使用
     - サーバーコンポーネントでの翻訳
     - クライアントでの動的翻訳

3. **実装方針**:
   - ディレクトリベースのルーティング
     - `/[locale]/route`パターンでのURL構造
     - ロケールパラメータの自動抽出
   - 言語切り替え機能
     - ユーザー選択の永続化（localStorage）
     - ヘッダーベースの自動言語検出
   - フォールバック言語の設定
     - 翻訳キー欠落時の代替表示
     - デフォルト言語の設定
   - 翻訳管理システムとの連携（オプション）
     - 外部翻訳サービスとの連携可能性
     - CI/CDパイプラインでの翻訳同期

## 11. モニタリングと分析

### Cloudflare Analytics + カスタムロギング（確定）

1. **アプリケーションモニタリング**:

   - エラー率とその分布
     - エラータイプ別の発生頻度
     - エラーのトレンド分析
     - 重大度別の分類
   - レスポンスタイム
     - APIエンドポイント別のパフォーマンス指標
     - 各ルートのサーバーコンポーネントレンダリング時間
     - クライアントサイド処理時間
   - APIリクエスト量
     - エンドポイント別使用率
     - 時間帯別トラフィックパターン
     - 異常トラフィックの検出
   - リソース使用率
     - ワーカーの計算リソース使用状況
     - ストレージ使用量推移
     - コスト予測と最適化ポイント

2. **ユーザー行動分析**:

   - ページビューとセッション
     - ページごとの滞在時間
     - バウンス率と離脱ポイント
     - ユーザーフロー分析
   - 機能利用統計
     - 主要機能の使用頻度
     - 操作シーケンスパターン
     - 未使用機能の特定
   - コンバージョンフロー
     - 目標達成率
     - ドロップオフポイントの特定
     - コンバージョン最適化ポイント
   - エンゲージメント指標
     - リピート率と定着度
     - セッションあたりのアクション数
     - ユーザーセグメント別の行動パターン

3. **AIエージェント評価**:

   - 完了率
     - ワークフロー別完了率
     - エラー発生ポイントの分析
     - ユーザー介入率
   - レスポンス品質
     - NPS（Net Promoter Score）
     - 直接フィードバック評価
     - 出力の一貫性測定
   - エラー率
     - モデル制約によるエラー（トークン超過など）
     - ツール実行エラー
     - コンテキスト関連エラー
   - ユーザー満足度
     - 会話継続率
     - フィードバック評価
     - 機能再利用率
   - Mastra Evalsによる自動評価
     - 回答の関連性スコア
     - 指示に対する忠実性
     - 出力品質の一貫性

4. **アラート設定**:
   - エラー率閾値アラート
     - 短時間での急激なエラー増加検知
     - 特定エラータイプの閾値超過通知
     - サービス停止リスクの早期警告
   - パフォーマンス低下検知
     - レスポンスタイム悪化アラート
     - 処理遅延の傾向分析
     - 定期的なパフォーマンスレポート
   - リソース使用率警告
     - 上限到達前の警告通知
     - 使用量の急激な増加アラート
     - コスト最適化提案
   - セキュリティアラート
     - 異常アクセスパターンの検出
     - 認証失敗の閾値超過通知
     - データアクセス異常の監視

## 12. スケーリング戦略

### 段階的拡張計画（確定）

1. **初期フェーズ (小規模 MVPフェーズ)**:
   - Cloudflare D1 + KV（無料枠内で運用）
     - SQLite互換データベースの最適化
     - インデックス設計の最適化
     - リレーションの効率的設計
   - シンプルなマイクロサービス構造
     - 機能ごとのAPIルート設計
     - サーバーレスファンクションの適切な分割
     - ドメインごとの責任分離
   - 基本的なアナリティクス
     - 最小限の使用統計収集
     - ユーザーフィードバックの収集体制
     - 重要指標の定義と測定
2. **成長フェーズ (ユーザー増加時)**:

   - キャッシング戦略の最適化
     - KVを活用した効率的キャッシュレイヤー
     - CDNキャッシュルールの最適化
     - クライアントサイドキャッシュの活用
   - パフォーマンスチューニング
     - サーバーコンポーネントの最適化
     - データフェッチング戦略の改善
     - バンドルサイズの最適化
   - データベース効率化
     - クエリ最適化とN+1問題の解消
     - 適切な非正規化の導入
     - バッチ処理の導入

3. **スケールフェーズ (本格運用時)**:

   - PlanetScaleへの移行計画
     - 段階的なデータ移行戦略
     - ダウンタイムゼロの移行手法
     - シャーディング考慮の設計
   - マイクロフロントエンド（必要に応じて）
     - 機能チームごとの独立開発
     - ランタイム統合アーキテクチャ
     - 共有コンポーネントライブラリ
   - 高度なモニタリングと自動スケーリング
     - 複合メトリクスに基づく自動スケーリング
     - 予測的リソース割り当て
     - 費用最適化自動化

4. **Mastraのスケーリング**:
   - エージェントとモデルの最適化
     - 目的に応じたモデル選択
     - コンテキスト長の最適化
     - バッチ処理の導入
   - RAG実装の効率化
     - チャンク戦略の最適化
     - 埋め込みインデックスの効率化
     - キャッシュ戦略の導入
   - ベクトルストアのVectorizeへの移行
     - データ移行戦略
     - 検索精度とパフォーマンスの最適化
     - 段階的な容量拡張

## 12.5 環境変数とシークレット管理

アプリケーションの環境変数とシークレットを安全に管理するための標準的な方法を定義します。

### 環境変数ファイル（確定）

| ファイル      | 目的                       | バージョン管理 |
| ------------- | -------------------------- | -------------- |
| `.env.sample` | テンプレート（サンプル値） | ✅ 対象        |
| `.env.local`  | ローカル開発環境設定       | ❌ 対象外      |
| `.env.test`   | テスト実行環境設定         | ✅ 対象        |
| `.env.e2e`    | E2Eテスト実行環境設定      | ✅ 対象        |

### 標準環境変数（確定）

```bash
# アプリケーション設定
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:3000/api
NEXT_PUBLIC_APP_ENV=development

# Cloudflare設定
CF_ACCOUNT_ID=your-account-id-here
CF_API_TOKEN=your-api-token-here

# データベース設定
D1_DATABASE_ID=your-d1-database-id-here
KV_NAMESPACE_ID=your-kv-namespace-id-here
R2_BUCKET_NAME=automationa-tools-storage

# 認証設定
JWT_SECRET=your-secret-here-minimum-32-chars
JWT_EXPIRES_IN=7d
COOKIE_SECRET=your-cookie-secret-here

# 外部API設定
OPENAI_API_KEY=your-openai-api-key-here
```

### シークレット管理原則

1. **ローカル開発**:

   - `.env.local`ファイルにシークレットを保存（バージョン管理対象外）
   - 開発チーム内で安全にシークレットを共有する方法を確立
   - 自動生成されたダミー値をローカルテスト用に使用

2. **CI/CD環境**:

   - GitHub Secretsを使用してシークレットを保存
   - 環境変数として安全にワークフローに提供
   - 本番シークレットへのアクセスを最小限の管理者に制限

3. **本番環境（Cloudflare）**:
   - Cloudflare環境変数とシークレットを使用
   - `wrangler secret put`コマンドでのシークレット設定
   - 環境ごとのシークレット分離（development, staging, production）

### 型の安全性

TypeScriptで環境変数の型安全性を確保するため、環境変数の型定義を提供します：

```typescript
// src/types/env.d.ts
declare namespace NodeJS {
  interface ProcessEnv {
    // アプリケーション設定
    NEXT_PUBLIC_APP_URL: string;
    NEXT_PUBLIC_API_URL: string;
    NEXT_PUBLIC_APP_ENV: 'development' | 'test' | 'staging' | 'production';

    // Cloudflare設定
    CF_ACCOUNT_ID?: string;
    CF_API_TOKEN?: string;

    // データベース設定
    D1_DATABASE_ID?: string;
    KV_NAMESPACE_ID?: string;
    R2_BUCKET_NAME?: string;

    // 認証設定
    JWT_SECRET: string;
    JWT_EXPIRES_IN: string;
    COOKIE_SECRET: string;

    // 外部API設定
    OPENAI_API_KEY?: string;
  }
}
```

## 13. 開発ワークフロー

### 標準開発プロセス（確定）

1. **環境設定**:

   - Node.js 18+ (LTS)
     - 開発チーム全体で同一バージョンの使用
     - nvmによるバージョン管理
     - .nvmrcファイルの活用
   - pnpm パッケージマネージャー
     - 厳格なロックファイル管理
     - monorepo構成の効率的管理
     - 依存関係の重複最小化
   - VSCode + 推奨拡張機能
     - ESLint, Prettier, Tailwind CSS IntelliSense
     - GitLens, Error Lens
     - TypeScript + JavaScript
     - 共通設定ファイル（.vscode/settings.json）の活用
   - ESLint/Prettier設定
     - 一貫したコーディング規約
     - 自動フォーマット設定
     - 厳格なルール適用

2. **Docker開発環境**

このプロジェクトはDockerを使用した一貫した開発環境を提供します。

Docker環境と通常のローカル環境のコマンドの対応関係は以下の通りです：

| 機能                 | Docker環境                                    | 通常環境          |
| -------------------- | --------------------------------------------- | ----------------- |
| 開発サーバー起動     | `./scripts/docker-dev.sh start`               | `pnpm dev`        |
| テスト実行           | `./scripts/docker-dev.sh test`                | `pnpm test`       |
| テスト（監視モード） | `docker-compose run --rm app pnpm test:watch` | `pnpm test:watch` |
| E2Eテスト            | `./scripts/docker-dev.sh e2e`                 | `pnpm test:e2e`   |
| ビルド               | `./scripts/docker-dev.sh build`               | `pnpm build`      |
| リント               | `./scripts/docker-dev.sh lint`                | `pnpm lint`       |
| 型チェック           | `docker-compose run --rm app pnpm type-check` | `pnpm type-check` |

Docker環境はチーム間の一貫性を保証しますが、パフォーマンスが必要な場合は通常環境も利用可能です。

3. **ブランチ戦略**:

   - メインブランチ: `main` (本番), `develop` (開発)
     - `main`への直接プッシュ禁止
     - `develop`から`main`へのマージは承認必須
     - リリースタグの活用
   - フィーチャーブランチ: `feature/名前`
     - 機能単位での分割
     - 小さな粒度の変更
     - 早期・頻繁なマージ
   - バグフィックス: `fix/説明`
     - 明確な問題特定
     - 最小限の修正範囲
     - テストケースの追加

4. **CI/CD**:

   - GitHub Actions自動化
     - プッシュごとの自動テスト
     - リント・型チェックの自動実行
     - 依存関係セキュリティチェック
   - テスト自動化とワークフロー
     - リントと型チェックのジョブ実行
     - ユニットテストの実行（カバレッジレポートの生成）
     - E2Eテストの実行（Playwrightによるブラウザテスト）
     - テスト結果をアーティファクトとして保存
   - 継続的テスト
     - 定期的な自動テスト実行（毎日）
     - 結果の自動通知（Slack連携）
     - 手動実行オプション
   - 本番環境への承認デプロイ
     - 複数レビュアーの承認
     - すべてのチェックを通過後のみデプロイ実行
     - Cloudflare Pagesへの自動デプロイ

5. **コードレビュー**:
   - プルリクエストテンプレート
     - 変更内容の明確な説明
     - テスト方法の記述
     - 影響範囲の明示
   - レビューチェックリスト
     - 設計原則への準拠
     - パフォーマンス考慮
     - セキュリティレビュー
     - アクセシビリティ確認
   - 最低1名の承認必須
     - 専門知識に基づくレビュアー選定
     - レビュー優先度の設定
     - タイムリーなフィードバック
   - 自動コード品質チェック
     - SonarQube/CodeClimate統合
     - 複雑度測定
     - テストカバレッジ確認

## 14. テスト戦略

### 多層テスト戦略（確定）

1. **単体テスト**:

   - ドメインロジックの完全カバレッジ
     - ドメインサービスの網羅的テスト
     - エンティティのビジネスロジックテスト
     - 値オブジェクトの検証
   - リポジトリモックによる分離テスト
     - インメモリリポジトリの活用
     - テスト用DBコンテナの利用
     - モック/スタブによる外部依存の分離
   - Vitest + React Testing Library
     - 高速な並列テスト実行
     - コンポーネントの振る舞いテスト
     - アクセシビリティ考慮のテスト手法

2. **統合テスト**:

   - APIエンドポイントテスト
     - エンドツーエンドのリクエスト/レスポンステスト
     - 認証/認可機能の検証
     - エラー応答の一貫性確認
   - DBインタラクションテスト
     - トランザクション整合性の検証
     - マイグレーションテスト
     - 実際のクエリパフォーマンス測定
   - Mastraワークフローテスト
     - ワークフロー全体の実行テスト
     - エージェント間連携の検証
     - エラー回復メカニズムの確認

3. **E2Eテスト**:

   - 主要ユーザーフロー
     - 登録から利用までの一連のフロー
     - 複雑なデータ入力と操作シーケンス
     - マルチステップフォーム完了フロー
   - クリティカルパス
     - コア機能の動作保証
     - 複数デバイス・ブラウザでの検証
     - パフォーマンス指標の測定
   - Playwright利用
     - クロスブラウザテスト
     - モバイル/デスクトップの検証
     - アクセシビリティテストの統合

4. **段階的カバレッジ目標**:

   - 開発フェーズに応じたテストカバレッジの段階的向上
   - 重要なコードパスに対する厳格なカバレッジ要件
   - フェーズごとの目標:
     - フェーズ1 (開発初期): 最低60%
     - フェーズ2 (開発中期): 最低70%
     - フェーズ3 (開発後期/本番): 最低80%
   - 領域別カバレッジ目標:
     - ドメイン層: 90%以上
     - インフラ層: 80%以上
     - UI層: 70%以上
   - 環境変数（COVERAGE_PHASE）による柔軟な適用
   - 特に重要なディレクトリ（domain/, infrastructure/, mastra/）でより高いカバレッジを要求

5. **Mastra固有のテスト**:
   - Evalsによる自動評価
     - 目標達成度の定量評価
     - コンテキスト理解度の測定
     - 複数シナリオでの一貫性検証
   - エージェント出力の品質評価
     - 出力精度の統計的分析
     - ユーザー指示への適合度
     - 応答品質の人間評価との相関
   - RAG機能の評価
     - 検索精度と関連性のテスト
     - 知識統合の正確性
     - ソース引用の適切性評価

## 15. 変更容易性を確保するための設計原則

### 採用すべきパターン（確定）

1. **関心の分離**:

   - 単一責任の原則
     - 変更理由の局所化
     - 修正範囲の最小化
     - テスト対象の明確化
   - レイヤー分離
     - ドメインロジックの独立性保証
     - 技術的詳細からのビジネスルール保護
     - 依存方向の一方向性維持
   - インターフェース境界の明確化
     - 契約駆動開発
     - 実装詳細の隠蔽
     - モジュール間の疎結合

2. **依存性注入**:

   - コンストラクタインジェクション
     - 依存関係の明示化
     - テスト容易性の確保
     - 初期化時の依存解決
   - ファクトリー関数
     - 複雑なオブジェクト構築の抽象化
     - インスタンス生成ロジックの集中管理
     - 条件付き実装の提供
   - 依存の明示
     - 暗黙的なグローバル状態の排除
     - 副作用の局所化
     - 透明な依存関係グラフ

3. **インターフェース指向**:

   - 実装より抽象化
     - プログラミング対インターフェース
     - 実装交換の容易性
     - 拡張ポイントの提供
   - インターフェース契約の明確化
     - 期待される動作の明示
     - 事前条件と事後条件の定義
     - エラー条件の明文化
   - 依存性逆転の原則
     - 上位モジュールは下位モジュールに依存しない
     - 両方が抽象に依存
     - コントロールフローと依存方向の逆転

4. **モジュール分割**:

   - 機能ごとの分割
     - ビジネスドメイン単位の分割
     - 内部結合度の最大化
     - 外部結合度の最小化
   - 独立したテスト
     - 単体テストの容易性
     - モックの利用最小化
     - 副作用のないテスト
   - 明確な責任範囲
     - ドメイン境界の明示
     - 機能の重複回避
     - インターフェースの一貫性

5. **設定の外部化**:

   - 環境変数の活用
     - 環境ごとの設定分離
     - シークレット管理の適切な方法
     - デフォルト値の提供
   - 設定ファイルの分離
     - 環境別設定ファイル
     - オーバーライド階層の明確化
     - バージョン管理との統合
   - 依存関係の明示的宣言
     - パッケージ管理の厳格化
     - バージョン固定と更新戦略
     - 依存グラフの監視と最適化

6. **コメント記述の原則**:

   - 目的指向コメント
     - なぜそのコードが存在するのかを説明
     - 複雑なロジックの背景や意図を明確化
     - 将来的な変更に関する注意点の記述
   - JSDocスタイルの採用
     ```typescript
     /**
      * 関数やクラスの説明
      * @param {型} パラメータ名 - パラメータの説明
      * @returns {型} 戻り値の説明
      * @throws {エラー型} 発生する可能性のあるエラーの説明
      */
     ```
   - コードブロックへのコメント
     - 複雑なアルゴリズムの前に説明を記述
     - 条件分岐やループの意図を明確化
     - ビジネスルールとの関連性を説明
   - コメントの鮮度維持
     - コード変更時のコメント更新の徹底
     - 古くなったコメントの除去
     - TODOコメントのチケット番号リンク
   - 自己説明的コードの優先
     - 明確な命名規則による自己説明性
     - コメントによる補足説明
     - 必要最小限のコメントで簡潔さを保持
   - コメントスタイルの一貫性
     - 単一行コメントには `// コメント` 形式を使用
     - 複数行コメントには `/* コメント */` 形式を使用
     - JSDocコメントには `/** ドキュメントコメント */` 形式を使用
   - ドキュメンテーションコメントの充実
     - 公開API/コンポーネントには必ずJSDocコメントを付与
     - クラス/関数の責務を明記
     - 使用例やユースケースの提示
   - 言語特性に応じたコメント
     - 各言語の慣習に従ったコメントスタイル
     - 言語固有の機能を活用したドキュメント生成
     - IDEの支援機能を最大限活用できるフォーマット

   **JSDocの詳細例**:

   関数へのJSDoc:

   ```typescript
   /**
    * ユーザー認証を実行し、JWTトークンを返却します
    *
    * @param {string} email - ユーザーのメールアドレス
    * @param {string} password - ユーザーの平文パスワード
    * @returns {Promise<{token: string, user: User}>} 認証トークンとユーザー情報
    * @throws {AuthError} 認証情報が不正な場合にスロー
    * @throws {ServiceError} データベース接続エラー時にスロー
    * @example
    * // 認証の使用例
    * const { token, user } = await authenticateUser('user@example.com', 'password123');
    */
   async function authenticateUser(
     email: string,
     password: string
   ): Promise<{ token: string; user: User }> {
     // 実装...
   }
   ```

   クラスへのJSDoc:

   ```typescript
   /**
    * ユーザーリポジトリクラス
    * ユーザーデータの永続化と取得を担当します
    *
    * @implements {UserRepository} ユーザーリポジトリインターフェースを実装
    * @since 1.0.0
    */
   class DrizzleUserRepository implements UserRepository {
     /**
      * コンストラクタ
      *
      * @param {DrizzleClient} db - Drizzle DBクライアントインスタンス
      */
     constructor(private db: DrizzleClient) {}

     /**
      * IDによるユーザー検索
      *
      * @param {string} id - 検索対象ユーザーID
      * @returns {Promise<User | null>} 見つかったユーザーまたはnull
      */
     async findById(id: string): Promise<User | null> {
       // 実装...
     }
   }
   ```

   **コメントスタイルの一貫性の重要性**:

   コメントスタイルを一貫させることで、以下の利点があります:

   - 可読性の向上: チーム全体が同じスタイルに慣れることで、コードベース全体の理解が容易になります
   - 自動ドキュメント生成: 一貫したJSDocスタイルにより、TypeDocなどのツールで自動的にAPI参照ドキュメントを生成できます
   - IDE機能の活用: 適切に書かれたJSDocは、VSCodeなどのIDEでのコード補完や型情報表示に使用されます
   - 知識移転の促進: 新しいチームメンバーが既存コードを理解する速度が向上します

   **自己説明的コードの重要性**:

   コードは可能な限り自己説明的であるべきです:

   - 良い命名規則: 変数、関数、クラス名が目的を明確に表現する

     ```typescript
     // 悪い例
     const u = getD(); // 何を取得しているのか不明瞭

     // 良い例
     const user = getCurrentAuthenticatedUser(); // 明確な命名
     ```

   - 明確な関数シグネチャ: パラメータ名と戻り値の型から目的が読み取れる

     ```typescript
     // 悪い例
     function process(a, b) {
       /* ... */
     }

     // 良い例
     function calculateTotalPrice(itemPrice: number, quantity: number): number {
       /* ... */
     }
     ```

   - 適切な抽象化: 複雑なロジックを意味のある関数名に抽象化

     ```typescript
     // 悪い例 - 複雑なロジックが直接インライン
     if (
       user &&
       user.subscription &&
       (user.subscription.status === 'active' || user.subscription.status === 'trial') &&
       new Date() < new Date(user.subscription.expiresAt)
     ) {
       // アクセス許可
     }

     // 良い例 - 意図を明確にする関数に抽象化
     if (hasValidSubscription(user)) {
       // アクセス許可
     }
     ```

   **コメントとコードのバランス**:

   - コメントは「なぜ」を説明し、コードは「何を」と「どのように」を表現すべき
   - 自明なコードにはコメントを避け、複雑な意図や非直感的な選択の説明にコメントを使用
   - コメントが多すぎるとメンテナンスコストが増加するため、コードの自己説明性を高める方が優先

## 16. Mastraを活用したAIシステム構築

### Mastra アーキテクチャ（確定）

Mastraは日常業務を簡略化するAIシステム構築に最適なフレームワークです。以下のコンポーネントで構成されます：

1. **エージェント設計**:

   - 明確な責任を持つ特化型エージェント
   - 再利用可能なツールセット
   - モジュール化された会話フロー
   - 高度なプロンプト最適化機能
   - 複数モデル対応（GPT-4oなど）
   - 例：

     ```typescript
     // mastra/agents/task_manager_agent.ts
     import { createAgent } from '@mastrajs/core';
     import { z } from 'zod';

     export const taskManagerAgent = createAgent({
       name: 'TaskManager',
       description: 'タスク管理を支援するエージェント',
       tools: [createTask, updateTask, listTasks, searchTask],
       systemMessage: `あなたはユーザーのタスク管理を支援するアシスタントです。`,
       model: 'gpt-4o',
     });
     ```

2. **ワークフロー構成**:

   - 複数エージェントの連携
   - ステップごとのモジュール化
   - 条件分岐とループによる柔軟性
   - エラーハンドリングとリトライ機能
   - 分散実行と並列処理のサポート
   - 例：

     ```typescript
     // mastra/workflows/daily_report_workflow.ts
     import { createWorkflow, step } from '@mastrajs/core';
     import { z } from 'zod';

     export const dailyReportWorkflow = createWorkflow({
       name: 'DailyReport',
       description: '日次レポート作成ワークフロー',
       inputSchema: z.object({
         date: z.string(),
         userId: z.string()
       }),
       steps: [
         step('fetchTaskData', {
           execute: async ({ date, userId }) => {
             // タスクデータ取得ロジック
             return { tasks: [...] };
           }
         }),
         step('generateReport', {
           execute: async ({ tasks }) => {
             // レポート生成エージェント呼び出し
             return reportGeneratorAgent.run({ tasks });
           }
         }),
         step('saveReport', {
           execute: async ({ report, userId, date }) => {
             // レポート保存ロジック
             return { success: true, reportId: '...' };
           }
         })
       ]
     });
     ```

3. **ツール実装**:

   - 明確な入出力スキーマ
   - 再利用性を重視
   - サービス連携のカプセル化
   - 自動型生成とバリデーション
   - オブザーバブルな実行追跡
   - 例：

     ```typescript
     // mastra/tools/api_integration_tool.ts
     import { createTool } from '@mastrajs/core';
     import { z } from 'zod';

     export const fetchDataTool = createTool({
       name: 'fetchData',
       description: '外部APIからデータを取得する',
       inputSchema: z.object({
         endpoint: z.string(),
         parameters: z.record(z.string()).optional(),
       }),
       outputSchema: z.object({
         data: z.any(),
         status: z.number(),
       }),
       execute: async ({ endpoint, parameters }) => {
         // API呼び出しロジック
         return { data, status };
       },
     });
     ```

4. **RAG（検索拡張生成）実装**:

   - ベクトル検索による知識ベース活用
   - 効率的な埋め込み管理
   - コンテキスト拡張によるレスポンス改善
   - マルチモーダル埋め込みサポート
   - リアルタイムインデックス更新
   - 例：

     ```typescript
     // mastra/rag/vector_store.ts
     import { createVectorStore, createVectorQueryTool } from '@mastrajs/core';

     // ベクトルストア設定
     export const knowledgeBase = createVectorStore({
       provider: 'cloudflare',
       indexName: 'company-knowledge',
       embeddings: openAIEmbeddings,
     });

     // 検索ツール作成
     export const searchKnowledgeBaseTool = createVectorQueryTool({
       vectorStore: knowledgeBase,
       name: 'searchKnowledge',
       description: '社内ナレッジを検索する',
       returnSourceDocuments: true,
     });
     ```

5. **メモリ管理**:

   - 会話履歴の保持
   - コンテキストの維持
   - 状態管理の最適化
   - 長期メモリと短期メモリの統合
   - シームレスなコンテキスト共有
   - 例：

     ```typescript
     // mastra/memory/memory_config.ts
     import { createBufferMemory } from '@mastrajs/core';

     export const conversationMemory = createBufferMemory({
       returnMessages: true,
       memoryKey: 'chat_history',
       inputKey: 'input',
       outputKey: 'output',
       maxTokenLimit: 8000,
       summarizationStrategy: 'automatic',
     });
     ```

6. **評価システム（Evals）**:

   - エージェント出力の品質評価
   - 自動テストと継続的改善
   - メトリクスによる定量評価
   - ヒューマンフィードバック統合
   - A/Bテスト機能
   - 例：

     ```typescript
     // mastra/evals/response_evaluation.ts
     import { createEvaluation, AnswerRelevancyMetric } from '@mastrajs/core';

     export const responseQualityEval = createEvaluation({
       name: 'ResponseQuality',
       metrics: [
         new AnswerRelevancyMetric(),
         new FaithfulnessMetric(),
         new ToxicityMetric(),
         new UserSatisfactionMetric(),
       ],
       evaluationPrompt: `評価者として、以下の応答の品質を評価してください...`,
       model: 'gpt-4o',
     });
     ```

7. **モニタリングとオブザーバビリティ**:

   - 詳細な実行ログ
   - パフォーマンスメトリクス収集
   - トレース機能
   - リアルタイムアラート
   - ダッシュボード連携
   - 例：

     ```typescript
     // mastra/observability/monitoring.ts
     import { configureMastraMonitoring } from '@mastrajs/core';

     export const setupMonitoring = () => {
       configureMastraMonitoring({
         logLevel: 'info',
         metricsEnabled: true,
         tracingEnabled: true,
         exporters: {
           console: true,
           cloudflare: process.env.CLOUDFLARE_ANALYTICS_TOKEN ? true : false,
         },
         samplingRate: 0.1,
       });
     };
     ```

### Mastraによるシステム構築のベストプラクティス

1. **関心の分離**:

   - 各エージェントに明確な責任を持たせる
     - 単一目的の専門エージェント設計
     - 細粒度の責任定義
     - エージェント間の明確な境界
   - ツールを再利用可能な単位で設計
     - 単一責任の原則に基づくツール設計
     - 入出力スキーマの厳密な定義
     - コンテキスト独立性の確保
   - ワークフローステップの適切な分割
     - 単一の変換/処理を行うステップ
     - ステップ間の明確なデータフロー
     - エラー分離と回復メカニズム

2. **型安全性の確保**:

   - Zodスキーマによる入出力の厳密な定義
     - すべての入出力の検証
     - ランタイム型安全性の確保
     - 自己文書化するスキーマ
   - TypeScriptの活用による開発時エラー検出
     - 厳格なTypeScript設定
     - ジェネリック型の活用
     - 型の合成と再利用
   - スキーマ駆動開発の採用
     - スキーマ先行設計
     - コード生成の活用
     - 型と実装の一貫性保証

3. **モジュール性と再利用**:

   - 共通機能をツールとして抽象化
     - 汎用ユーティリティツールの設計
     - ドメイン固有ツールの分離
     - バージョニングと互換性管理
   - エージェント間の知識共有
     - 共有コンテキストの設計
     - メモリ管理戦略
     - メタデータの伝播
   - ワークフローステップの再利用
     - 汎用ステップライブラリの構築
     - パラメータによるカスタマイズ
     - 合成可能なステップ設計

4. **テストと評価**:

   - 自動Evalsによる品質保証
     - 定量的評価メトリクスの設定
     - ユースケース別の評価基準
     - 継続的な品質監視
   - 単体テストでのエージェント動作確認
     - モックLLMを使用したテスト
     - 決定論的応答のシミュレーション
     - エッジケースの網羅
   - ワークフローの統合テスト
     - エンドツーエンドのワークフロー検証
     - 異常系のハンドリング確認
     - パフォーマンスとリソース使用のプロファイリング

5. **拡張性の確保**:
   - 新規エージェント追加の容易性
     - 一貫したエージェント作成パターン
     - プラグイン機構の設計
     - 既存エージェントへの影響最小化
   - ワークフローの段階的拡張
     - 単一目的から複合目的への段階的拡張
     - バージョン管理された拡張
     - 後方互換性の維持
   - 知識ベースの継続的更新
     - インクリメンタルな知識追加メカニズム
     - 情報の鮮度管理
     - コンテンツ品質の監視と改善

## 17. まとめ

このアーキテクチャ設計は、無料で始められ、段階的に拡張可能なMVPシステムの構築を可能にします。主要な強みは以下の通りです：

1. **変更容易性**: モジュール化されたアーキテクチャと明確な責任分離
2. **コスト効率**: Cloudflareの無料枠を最大活用した初期コスト最小化
3. **拡張性**: ビジネス成長に合わせた段階的スケーリングパス
4. **AI活用**: Mastraフレームワークによる柔軟なAIエージェント・ワークフロー構築
5. **開発効率**: 明確な構造と設計原則による開発速度の向上
6. **一貫性**: すべての開発者が共有できる明確なガイドライン
7. **品質保証**: 自動テストと評価による品質維持
8. **将来性**: 新技術や要件変更への柔軟な対応

この設計に従うことで、高品質なMVPをコスト効率良く開発し、将来の変更や成長に柔軟に対応できる基盤を構築できます。

## 付録: 開発準備チェックリスト

以下の項目を確認して、開発準備が整っていることを確認してください：

✅ **基本環境**

- [ ] Node.js v18.18.0以上（推奨：v20.10.0）が正しくインストールされている
- [ ] pnpm v8.10.0以上が正しくインストールされている
- [ ] Git 2.40.0以上がインストールされている
- [ ] VSCodeと必要な拡張機能がインストールされている

✅ **プロジェクト設定**

- [ ] リポジトリが正しくクローンされている
- [ ] 依存関係がすべてインストールされている (`pnpm install`の実行)
- [ ] `.env.local`ファイルが作成され、必要な環境変数が設定されている
- [ ] `pnpm dev`で開発サーバーが正常に起動する
- [ ] `pnpm test`でテストが正常に実行される
- [ ] `pnpm lint`でリントが正常に実行される

✅ **Cloudflare設定**

- [ ] Cloudflareアカウントが作成され、アクセス可能である
- [ ] D1データベースが正しく作成されている
- [ ] KVネームスペースが正しく作成されている
- [ ] R2バケットが正しく作成されている
- [ ] wrangler.tomlが正しく設定されている

✅ **リポジトリ設定**

- [ ] mainブランチが保護されている（プルリクエスト必須）
- [ ] GitHub Actionsのワークフローが設定されている
- [ ] GitHub Secretsに必要な値が設定されている(CF_API_TOKEN, CF_ACCOUNT_ID)

✅ **ディレクトリ構造**

- [ ] すべての必要なディレクトリが作成されている
- [ ] 基本的なファイル（エラーハンドラなど）が作成されている
- [ ] Next.jsのApp Router構造が正しく設定されている

## 付録: トラブルシューティング

### 一般的な問題と解決方法

#### Node.jsバージョンの問題

**症状**: パッケージのインストールエラーやNext.jsの起動エラー

**解決方法**:

```bash
# Node.jsバージョンの確認
node -v

# 推奨バージョンがインストールされていない場合
nvm install 20.10.0
nvm use 20.10.0

# 再度依存関係のインストール
rm -rf node_modules
pnpm install
```

#### pnpmコマンドが見つからないエラー

**症状**: `command not found: pnpm`エラーが表示される

**解決方法**:

```bash
# グローバルにpnpmをインストール
npm install -g pnpm

# または代替インストール方法
curl -fsSL https://get.pnpm.io/install.sh | sh -

# PATH環境変数を更新（必要に応じて）
export PATH="$HOME/.pnpm/bin:$PATH"
```

#### Cloudflare APIトークンの問題

**症状**: Cloudflareリソース作成時の認証エラー

**解決方法**:

1. [Cloudflareダッシュボード](https://dash.cloudflare.com/) > プロフィール > APIトークン へ移動
2. 「APIトークンの作成」をクリック
3. 「編集者」テンプレートを選択
4. アカウントリソースとD1、KV、R2の権限を追加
5. トークンを生成し、wranglerで再度ログイン：

```bash
wrangler login
```

#### TypeScriptエラー

**症状**: 型エラーやTSコンパイルエラー

**解決方法**:

```bash
# TypeScriptキャッシュをクリア
rm -rf .next
rm -rf node_modules/.cache

# 型チェックを実行
pnpm type-check

# エラー箇所を修正
```

#### Next.js開発サーバーの問題

**症状**: 開発サーバーが起動しない、または異常終了する

**解決方法**:

```bash
# ポートが使用中の場合は別のポートを使用
pnpm dev -- -p 3001

# .nextディレクトリを削除して再構築
rm -rf .next
pnpm dev
```

#### ESLint/Prettierの問題

**症状**: フォーマットやリントエラーが表示される

**解決方法**:

```bash
# ESLintの実行
pnpm lint

# Prettierの実行
pnpm format

# VSCode設定が正しいことを確認
cat .vscode/settings.json
```

### サポートリソース

問題が解決しない場合は、以下のリソースを参照してください：

- [Next.js ドキュメント](https://nextjs.org/docs)
- [Cloudflare Workers ドキュメント](https://developers.cloudflare.com/workers/)
- [Drizzle ORM ドキュメント](https://orm.drizzle.team/docs/overview)
- チームのSlackチャンネル - #mvp-application-support

また、GitHubのIssueセクションでサポートを求めることもできます。
プロジェクト固有の問題は、リポジトリのIssuesに報告してください。

## 付録: 設計原則チートシート

### 1. SOLID原則

- **単一責任の原則 (SRP)**: 1つのクラスは1つの理由だけで変更される
- **オープン・クローズドの原則 (OCP)**: 拡張に対してオープン、修正に対してクローズド
- **リスコフの置換原則 (LSP)**: サブタイプはそのベースタイプと置換可能である
- **インターフェース分離の原則 (ISP)**: クライアントに不要なインターフェースを強制しない
- **依存関係逆転の原則 (DIP)**: 上位モジュールは下位モジュールに依存せず、両者は抽象に依存

### 2. クリーンアーキテクチャの核心

- **独立性**: フレームワーク、UI、データベースから独立したビジネスロジック
- **テスト容易性**: 外部依存なしでビジネスルールをテスト可能
- **UI独立**: UIの変更がシステムに影響しない
- **データベース独立**: データベース変更がビジネスルールに影響しない
- **依存方向**: 依存関係は常に内側（ドメイン）に向かう

### 3. DDD（ドメイン駆動設計）のエッセンス

- **ユビキタス言語**: チーム全体での共通言語の使用
- **境界付きコンテキスト**: 明確な境界を持つドメインの分割
- **エンティティと値オブジェクト**: 識別子を持つオブジェクトと持たないオブジェクトの区別
- **集約**: 関連するエンティティと値オブジェクトのクラスター
- **リポジトリ**: 永続化の詳細を隠蔽するデータアクセス抽象化
- **ドメインサービス**: エンティティに属さないドメインロジック

### 4. Mastra設計原則

- **単一目的エージェント**: 各エージェントは明確に定義された単一の責任を持つ
- **明確なツールインターフェース**: すべてのツールは明確な入出力スキーマを持つ
- **ステップごとの責任分離**: ワークフローの各ステップは単一の責任を持つ
- **再利用性**: エージェント、ツール、ワークフローステップは再利用可能に設計
- **コンテキスト管理**: 適切なメモリ戦略によるコンテキストの維持
- **自動評価**: Evalsによる継続的な品質評価

## 付録: 技術スタックリファレンス

| カテゴリ                | 技術               | バージョン                | 目的                         |
| ----------------------- | ------------------ | ------------------------- | ---------------------------- |
| **言語/フレームワーク** | TypeScript         | 5.3.2+                    | 型安全なコード記述           |
|                         | Next.js            | 14.0.3+                   | フロント/バックエンド統合    |
| **インフラ**            | Cloudflare Pages   | -                         | ホスティング                 |
|                         | Cloudflare Workers | -                         | サーバーレス処理             |
|                         | Cloudflare D1      | 1.5.1+                    | データベース                 |
|                         | Cloudflare KV      | -                         | キャッシュ                   |
|                         | Cloudflare R2      | -                         | ファイルストレージ           |
| **AIフレームワーク**    | Mastra             | 1.0.0+                    | AIエージェント・ワークフロー |
| **データアクセス**      | Drizzle ORM        | 0.29.0+                   | データベースアクセス         |
| **UI**                  | React              | 18.2.0+                   | UIコンポーネント             |
|                         | TailwindCSS        | 3.3.5+                    | スタイリング                 |
|                         | shadcn/ui          | -                         | UIコンポーネント             |
| **状態管理**            | Zustand            | 4.4.6+                    | クライアント状態管理         |
|                         | TanStack Query     | 5.8.4+                    | サーバー状態管理             |
| **フォーム処理**        | React Hook Form    | 7.48.2+                   | フォーム状態管理             |
|                         | Zod                | 3.22.4+                   | スキーマ検証                 |
| **国際化**              | next-intl          | 3.2.1+                    | 多言語対応                   |
| **テスト**              | Vitest             | 0.34.6+                   | 単体/統合テスト              |
|                         | Testing Library    | 14.1.2+                   | コンポーネントテスト         |
|                         | Playwright         | 1.40.0+                   | E2Eテスト                    |
| **開発環境**            | Node.js            | v18.18.0+（v20.10.0推奨） | JavaScript実行環境           |
|                         | pnpm               | 8.10.0+                   | パッケージマネージャー       |
|                         | Docker             | 最新                      | コンテナ化開発環境           |

この包括的な設計ガイドは、無料プランで構築できる変更容易性と拡張性を持つMVPアーキテクチャの完全なロードマップを提供します。特にMastraを活用したAIシステム構築のベストプラクティスを含め、チーム全体が共通の理解を持ち、一貫した方法で開発を進めるための基盤となります。

### 主要なnpmスクリプト（確定）

```json
"scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "lint": "next lint",
  "format": "prettier --write \"**/*.{js,ts,tsx,json,md}\"",
  "type-check": "tsc --noEmit",
  "test": "vitest run",
  "test:watch": "vitest",
  "test:coverage": "vitest run --coverage",
  "test:coverage:check": "vitest run --coverage && node scripts/check-coverage.js",
  "test:coverage:phase1": "COVERAGE_PHASE=1 vitest run --coverage && COVERAGE_PHASE=1 node scripts/check-coverage.js",
  "test:coverage:phase2": "COVERAGE_PHASE=2 vitest run --coverage && COVERAGE_PHASE=2 node scripts/check-coverage.js",
  "test:coverage:phase3": "COVERAGE_PHASE=3 vitest run --coverage && COVERAGE_PHASE=3 node scripts/check-coverage.js",
  "test:e2e": "playwright test",
  "test:ci": "vitest run && playwright test",
  "test:changed": "vitest related --run $(git diff --name-only --staged)",
  "db:generate": "drizzle-kit generate",
  "db:push": "drizzle-kit push",
  "db:studio": "drizzle-kit studio",
  "prepare": "husky install"
}
```

これらのスクリプトを使用して、開発・テスト・ビルドなどの作業を行います。
